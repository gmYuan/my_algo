# code1086- 前五科的均分

## 实现思路

1 方法1: 快速选择
  - 明确快速选择 和 快速排序的 区别

2 方法2: 最小堆
  - 明确题意转化

## 参考文档

[01- 译文参考](https://www.cnblogs.com/cnoodle/p/13722300.html)


## 代码实现

1 方法1: 快速选择
  - 时间复杂度：O(n)
  - 空间复杂度：O(n)

```ts
function highFive(items: number[][]): number[][] {
  // S1 获取id: [score1, score2...] 映射关系
  const record = new Map<number, number[]>();
  items.forEach(([id, score]) =>
    record.set(id, [...(record.get(id) || []), score])
  );

  // S2 获取每个id对应的前5高分数的 平均数
  return [...record.entries()]
    .map(([id, scores]) => {
      // 保证每个id成绩数组的 前5个元素是第5大的，内部顺序不保证，即topK
      findTop5(scores, 0, scores.length - 1, 4);
      // 获取其前5高分数的 平均数
      return [id, ~~(scores.slice(0, 5).reduce((a, b) => a + b) / 5)];
    })
    .sort(([id1], [id2]) => id1 - id2);
}

function findTop5(arr: number[], l: number, r: number, tdx: number) {
  if (l >= r) return;
  const p = partition(arr, l, r); // 修复函数名拼写
  if (p === tdx) return;
  if (p < tdx) findTop5(arr, p + 1, r, tdx);
  if (p > tdx) findTop5(arr, l, p - 1, tdx);
}

function partition(arr: number[], l: number, r: number): number {
  const rdx = ~~(Math.random() * (r - l + 1)) + l;
  swap(arr, l, rdx);
  const x = arr[l];
  // 保证 [l, i) 都 >= x;  (j, r]都 <=x
  let i = l + 1,
    j = r;
  while (1) {
    while (i <= j && arr[i] > x) i++;
    while (i <= j && arr[j] < x) j--;
    if (i >= j) break;
    swap(arr, i++, j--);
  }
  swap(arr, l, j);
  return j;
}
function swap(arr: number[], i: number, j: number) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}

```

2 方法2：最大堆
  - 时间复杂度：O(nlog5)
  - 空间复杂度：O(n)

```ts
function highFive(items: number[][]): number[][] {
  // S1 创建id和scores映射关系
  const record = items.reduce((map, [id, score]) => {
    map.set(id, [...(map.get(id) ?? []), score]);
    return map;
  }, new Map<number, number[]>());

  // S2 使用大小为5的最小堆获取最大的5个分数
  return [...record.entries()]
    .map(([id, scores]) => {
      const heap = minHeap<number>((a, b) => a < b);
      // 维护大小为5的最小堆，使用链式调用
      scores.forEach((score) =>
        heap.size() < 5
          ? heap.add(score)
          : score > heap.peek() && (heap.remove(), heap.add(score))
      );

      // 计算平均值，使用Array.from
      const sum = Array.from({ length: 5 }, heap.remove).reduce(
        (a, b) => a + b,
        0
      );
      return [id, ~~(sum / 5)];
    })
    .sort((a, b) => a[0] - b[0]);
}

function minHeap<T>(compare: (a: T, b: T) => boolean) {
  const heap: Array<T> = [];
  return {
    size: () => heap.length,
    empty: () => heap.length === 0,
    // 查看堆顶元素
    peek: () => heap[0],
    // 在末尾新增
    add: (item: T) => {
      heap.push(item);
      siftUp(heap.length - 1);
    },
    // 去除堆顶元素
    remove: (): T => {
      if (heap.length === 0) return;
      const ret = heap[0];
      swap(0, heap.length - 1);
      heap.pop();
      siftDown(0);
      return ret;
    },
  };

  function siftUp(idx: number) {
    while (idx > 0) {
      const pdx = ~~((idx - 1) / 2);
      // compare为true，表示a < b，即 当前元素 < parent值
      const willUp = compare(heap[idx], heap[pdx]);
      if (!willUp) break;
      swap(idx, pdx);
      idx = pdx;
    }
  }

  function siftDown(idx: number) {
    while (1) {
      const ldx = idx * 2 + 1;
      const rdx = idx * 2 + 2;
      let next = idx;
      // 如果左子元素较小，则 可能需要让当前元素 下沉
      if (ldx < heap.length && compare(heap[ldx], heap[next])) next = ldx;
      // 如果右子元素较小，则 可能需要让当前元素 下沉
      if (rdx < heap.length && compare(heap[rdx], heap[next])) next = rdx;
      if (next === idx) break;
      swap(idx, next);
      idx = next;
    }
  }

  function swap(i: number, j: number) {
    [heap[i], heap[j]] = [heap[j], heap[i]];
  }
}
```