# code1095- 山脉数组中查找目标值

## 实现思路

1 方法1：通用二分法

1.1 通过quickFind，快速找到分割点pdx

1.2 依次对(-1, pdx) 和 (pdx, len) 有序区间，进行二分查找

1.3 开区间表示 当前未处理的元素不包括 边界值

2 本题技巧:
  - 可以通过抽象出quickFind里的condition方法，来复用二分查找
  - 二分查找的重点是 找到分割点


## 参考文档

[01- 方法1参考文档](https://leetcode.cn/problems/find-in-mountain-array/solutions/1145587/go-ku-han-shu-er-fen-by-endlesscheng-dl6a/)


## 代码实现

1 方法1- 通用二分法
  - 时间复杂度：O(logn)
  - 空间复杂度：O(1)

```ts
function findInMountainArray(target: number, arr: MountainArray): number {
  const len = arr.length();
  // 找峰值：第一个非递增的分割点
  const pdx = quickFind(-1, len, (i) => arr.get(i) > arr.get(i + 1));
  if (arr.get(pdx) === target) return pdx;

  // >=t的最小值（左侧升序部分）
  const ldx = quickFind(-1, pdx, (i) => arr.get(i) >= target);
  if (arr.get(ldx) === target) return ldx;

  // <=t的最大值（右侧降序部分）
  // 易错点1：如果这里是>=t，会导致错误的更新r边界，而不是更新l边界
  // 易错点2: 最后的返回值需要加上pdx的偏移量
  const rdx = pdx + quickFind(-1, len - pdx, (i) => arr.get(pdx + i) <= target);
  return arr.get(rdx) === target ? rdx : -1;
}

function quickFind(l: number, r: number, condition: (i: number) => boolean) {
  while (l + 1 < r) {
    const mid = l + ((r - l) >> 1);
    if (condition(mid)) {
      r = mid;
    } else {
      l = mid;
    }
  }
  return r;
}
```