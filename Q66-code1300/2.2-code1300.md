# code1300- 转变数组后最接近目标值的数组和

## 实现思路

1. 理解题目：
  - 有一个数组 arr 和目标值 target
  - 找一个数 value
  - 把数组中所有大于 value 的数都改成 value
  - 让新数组的和尽可能接近 target

2.1 最简单直接的思路，即 暴力解法
  - 题目要求找出一个 value，那就尝试所有可能的 value，看哪个最接近
  - value 的范围是多少？
    - 太小（如负数）：没有意义，数组保持不变
    - 太大（超过数组里的 max）：数组不变，继续增大也没用
    - 结论：value 的范围是 [0, max(arr)]

2.2 具体过程
  - 从 value = 0 开始，到 value = max(arr)
  - 对每个 value：  
      - 遍历数组，计算新数组的和
      - 计算这个和与 target 的差值
      - 记录最小差值， 如果差值相同，取较小的value
  
  - 优化点：如果当前value的sum已经大于target了，后面的value只会让差值更大，所以可以提前结束
  - 时间复杂度：O(maxNum * n)
  - 空间复杂度：O(1)


2.3 观察规律
  - 随着 value 增大，sum 也会越来越大==> 单调性
    - x < val时，会保持不变
    - x >= val时，会变成 val
    - val 是依次递增的
    - 所以 sum(value) 必然也是依次递增的
  
  - sum(val) 单调递增，意味着
    - 如果 sum < target，继续增大 val 可能更接近 target
    - 如果 sum > target，继续增大 val 只会更远，所以可以提前结束


3.1 方法1- 二分查找思路
  - 在 [0, maxNum] 中找 val
  - 用二分找到一个位置，使得 sum(val) <= target 且 sum(val+1) > target
  - 最优解就在 val 和 val+1 之间
  - 即：找到最大的 val，使得 sum(val) <= target && sum(val+1) > target
  - 时间复杂度：O(n * log(maxNum))
  - 空间复杂度：O(1)

3.2 方法2- 前缀和 + 二分查找优化
  - 核心优化：在 calSum 函数中避免每次都遍历整个数组
  - 思路：
    1. 先对数组排序，这样可以利用单调性
    2. 构造前缀和数组，用于快速计算前 k 个数的和
    3. 外层二分查找 value（与方法1相同）
    4. 内层 calSum 优化：
       - 用二分查找找到最后一个 <= val 的索引 idx
       - 索引 0 到 idx 的数都 <= val，保持不变，用前缀和快速求和
       - 索引 idx+1 到末尾的数都 > val，都要变成 val，贡献为 (n - idx - 1) * val
  - 时间复杂度：O(n log n + log(maxNum) * log(n))
    - 排序：O(n log n)
    - 前缀和构造：O(n)
    - 外层二分：O(log(maxNum))
    - 内层二分（每次 calSum）：O(log n)
  - 空间复杂度：O(n)（前缀和数组）
  - 优势：当数组很大时，calSum 从 O(n) 优化到 O(log n)，适合多次调用 calSum 的场景

3.3 方法3- 枚举数组中的值 + 数学计算
  - 核心思路：最优的 value 要么是数组中的某个值，要么是某个值之间的值
  - 思路：
    1. 先对数组排序
    2. 枚举每个位置 i，假设 value 在 arr[i-1] 和 arr[i] 之间
    3. 对于每个位置，用数学方法计算最优的 value：
       - 假设 value 在 [arr[i-1], arr[i]) 之间
       - 此时前 i 个数保持不变，后面的数都变成 value
       - sum = prefixSum[i] + (n - i) * value
       - 令 sum = target，解得：value = (target - prefixSum[i]) / (n - i)
       - 如果 value 在 [arr[i-1], arr[i]) 范围内，则这是一个候选解
    4. 同时也要考虑 value 等于数组中的值的情况
  - 时间复杂度：O(n log n)
    - 排序：O(n log n)
    - 枚举：O(n)
    - 每个位置的计算：O(1)
  - 空间复杂度：O(n)（前缀和数组）
  - 优势：不需要二分查找，直接枚举所有可能的候选值，思路更直观


## 参考文档

[01- 方法1参考文档]()


## 代码实现

1 方法1- 二分查找
  - 时间复杂度：O(n * log(maxNum))
  - 空间复杂度：O(1)

```ts
function findBestValue(arr: number[], target: number): number {
  const max = Math.max(...arr);
  let l = -1, r = max + 1;
  // 双开区间：[-Infinity, l] 无限趋近于 <= target;  [r, Infinity] 无限趋近于 > target
  while (l + 1 < r) {
    const mid = l + ((r - l) >> 1);
    // 易错点1： 这里mid就是val值，而不是索引
    const sum = calSum(mid);
    sum <= target ? (l = mid) : (r = mid);
  }

  //易错点2： sum 可能小于 target，所以 需要比较绝对值
  const disL = Math.abs(calSum(arr, l) - target);
  const disR = Math.abs(calSum(arr, r) - target);
  return disL <= disR ? l : r; 
}

function calSum(val: number) {
  return arr.reduce((acc, cur) => {
    return acc + Math.min(cur, val);
  }, 0);
}
```


2 方法2- 使用前缀和 + 二分查找
  - 时间复杂度：O(n log n + log(maxNum) * log(n))
  - 空间复杂度：O(n)（前缀和数组）


```ts
function findBestValue(arr: number[], target: number): number {
  // 预处理：排序 + 构造前缀和数组
  arr.sort((a, b) => a - b)
  const prefixSums= arr.reduce((acc, cur) => {
    return [...acc, (acc.at(-1) || 0) + cur]
  }, [0])
 
  // 进行二分查找：获取target的猜测范围 + 获取sum(val) + 找到 sum(val)<= target的 最大val
  // 双开区间实现 不变量含义：l和r都是已处理过的值
  let l = 0, r = arr.at(-1) + 1
  while (l + 1 < r) {
    const val = (l + r) >> 1
    calSum(val) <= target ? l = val : r = val
  }
  // 由于要找到和 target最接近的sum，左侧<= taget 和 右侧 > target，不能保证abs那个更短
  // 所以需要 通过abs比较，确认是 左边还是右边 更接近target
  const diff1 = Math.abs(target - calSum(l))
  const diff2 = Math.abs(target - calSum(r))
  return diff1 <= diff2 ? l : r

  // 辅助函数：计算将所有大于 val 的值变成 val 后的数组和
  function calSum(val: number): number {
    // 内层二分查找：找到最后一个 <= val 的索引，即 <= val 的最大值所在 idx
    let l = -1, r = arr.length
    while (l + 1 < r) {
      let mid = (l + r) >> 1
      arr[mid] <= val ? l = mid : r = mid
    }
    let idx = l
    // 易错点1：前缀和数组索引关系
    // prefixSums[i] 是前 i 个数的和（索引 0 到 i-1）
    // 索引 0 到 idx 的数都 <= val，它们的和是 prefixSums[idx + 1]
    // 索引 idx+1 到 arr.length-1 的数都 > val，都要变成 val
    // 易错点2：注意是 (arr.length - idx - 1)，不是 (arr.length - idx)
    return prefixSums[idx + 1] + (arr.length - idx - 1) * val
  }
}
```

3 方法3- 枚举数组中的值 + 数学计算
  - 时间复杂度：O(n log n)
  - 空间复杂度：O(n)（前缀和数组）

```ts

```