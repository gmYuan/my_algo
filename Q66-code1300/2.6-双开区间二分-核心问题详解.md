# code1300 - 双开区间二分：两个核心问题详解

## 整体实现思路

### 你的代码结构

```typescript
function findBestValue(arr: number[], target: number): number {
  // 1. 预处理：排序 + 前缀和
  arr.sort((a, b) => a - b)
  const prefixSums = arr.reduce((acc, cur) => {
    return [...acc, (acc.at(-1) || 0) + cur]
  }, [0])
 
  // 2. 双开区间二分：找到 sum(value) <= target 的最大 value
  let l = 0, r = 100000 + 1
  while (l + 1 < r) {
    const val = (l + r) >> 1
    if (calSum(val) <= target) l = val
    else r = val
  }
  
  // 3. 比较 l 和 r，返回更接近 target 的
  const diff1 = Math.abs(target - calSum(l))
  const diff2 = Math.abs(target - calSum(r))
  return diff1 <= diff2 ? l : r
}
```

### 整体思路流程图

```
┌─────────────────────────────────────────┐
│ 步骤1：预处理                            │
│ • 排序数组：让分界点显现                 │
│ • 构建前缀和：快速计算左边部分的和       │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ 步骤2：双开区间二分                      │
│ • l: 满足 sum <= target 的最大值        │
│ • r: 第一个 sum > target 的             │
│ • 循环条件：l + 1 < r                    │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ 步骤3：比较候选值                        │
│ • 退出时 l 和 r 是相邻的两个候选值       │
│ • 比较哪个更接近 target                  │
│ • 如果差距相同，返回较小的（l）          │
└─────────────────────────────────────────┘
```

---

## 核心问题1：为什么 l = val，而不是 val + 1？

### 问题描述

```typescript
if (calSum(val) <= target) l = val  // ✅ 为什么不是 l = val + 1？
else r = val                        // ✅ 为什么不是 r = val - 1？
```

### 关键理解：双开区间的含义

**双开区间的核心思想：**
- `l` 表示：**已经确认满足条件的最大值**
- `r` 表示：**已经确认不满足条件的最小值**
- 区间 `(l, r)` 是**待探索的未知区域**

### 详细分析

#### 情况1：`calSum(val) <= target` 时

**如果 `l = val + 1`（错误做法）：**

```
假设 val = 3, calSum(3) = 9 ≤ 10
错误更新：l = 3 + 1 = 4

问题：
- val = 3 满足条件，但 l 被更新为 4
- 如果 3 就是答案，就被跳过了！
```

**如果 `l = val`（正确做法）：**

```
假设 val = 3, calSum(3) = 9 ≤ 10
正确更新：l = 3

含义：
- val = 3 满足条件，所以 l 可以等于 3
- l 表示"满足条件的最大值"，所以 l = 3 是合理的
- 继续向右探索，看是否有更大的满足条件的值
```

#### 情况2：`calSum(val) > target` 时

**如果 `r = val - 1`（错误做法）：**

```
假设 val = 4, calSum(4) = 11 > 10
错误更新：r = 4 - 1 = 3

问题：
- val = 4 不满足条件，但 r 被更新为 3
- 如果 4 是边界值，就被跳过了！
```

**如果 `r = val`（正确做法）：**

```
假设 val = 4, calSum(4) = 11 > 10
正确更新：r = 4

含义：
- val = 4 不满足条件，所以 r 可以等于 4
- r 表示"不满足条件的最小值"，所以 r = 4 是合理的
- 继续向左探索，看是否有更小的不满足条件的值
```

### 完整执行示例

**输入：** arr = [4, 9, 3], target = 10

```
初始：l = 0, r = 10

第1轮：val = 5
  calSum(5) = 12 > 10
  错误做法：r = 5 - 1 = 4  ❌
  正确做法：r = 5           ✅
  区间：(0, 5)

第2轮：val = 2
  calSum(2) = 6 ≤ 10
  错误做法：l = 2 + 1 = 3  ❌（如果 2 是答案就被跳过了）
  正确做法：l = 2           ✅
  区间：(2, 5)

第3轮：val = 3
  calSum(3) = 9 ≤ 10
  正确做法：l = 3           ✅
  区间：(3, 5)

第4轮：val = 4
  calSum(4) = 11 > 10
  正确做法：r = 4           ✅
  区间：(3, 4)

退出：l + 1 = 4 = r
l = 3（满足条件的最大值）
r = 4（第一个不满足的）
```

### 为什么不能用 `val + 1` 或 `val - 1`？

**核心原因：会跳过正确答案！**

```
如果 val 就是边界值：
- val 满足条件，但 l = val + 1 → 跳过了 val
- val 不满足条件，但 r = val - 1 → 跳过了 val

双开区间的精髓：
- l 和 r 可以等于 val
- 这样不会跳过任何可能的答案
```

### 对比：闭区间 vs 开区间

**闭区间写法（另一种常见写法）：**

```typescript
let left = 0, right = maxValue

while (left < right) {
  const mid = (left + right + 1) >> 1  // 注意 +1
  if (满足条件(mid)) {
    left = mid      // 不是 mid + 1
  } else {
    right = mid - 1 // 不是 mid
  }
}
```

**开区间写法（你的写法）：**

```typescript
let l = 0, r = maxValue + 1

while (l + 1 < r) {
  const mid = (l + r) >> 1
  if (满足条件(mid)) {
    l = mid      // 不是 mid + 1
  } else {
    r = mid      // 不是 mid - 1
  }
}
```

**两种写法等价，但开区间更直观！**

---

## 核心问题2：为什么需要比较 diff1 和 diff2，而不是直接取 l？

### 问题描述

```typescript
// 为什么不能直接 return l？
const diff1 = Math.abs(target - calSum(l))
const diff2 = Math.abs(target - calSum(r))
return diff1 <= diff2 ? l : r
```

### 关键理解：二分查找找到的是什么？

**二分查找的目标：** 找到 `sum(value) <= target` 的**最大值**

**但题目要求：** 找到 `|sum(value) - target|` 的**最小值**

**这两个目标不完全一致！**

### 详细分析

#### 退出时的状态

```
退出时：l + 1 = r

l: 满足 sum(l) <= target 的最大值
r: 第一个满足 sum(r) > target 的值

但是：
- sum(l) 可能 < target（在 target 左边）
- sum(r) 可能 > target（在 target 右边）
- 最优解可能在 l，也可能在 r！
```

#### 反例：为什么不能直接取 l？

**例子1：** arr = [2, 3, 5], target = 10

```
计算过程：
value = 0: sum = 0  ≤ 10 → l = 0
value = 1: sum = 3  ≤ 10 → l = 1
value = 2: sum = 6  ≤ 10 → l = 2
value = 3: sum = 8  ≤ 10 → l = 3
value = 4: sum = 9  ≤ 10 → l = 4
value = 5: sum = 10 ≤ 10 → l = 5
value = 6: sum = 10 > 10 → r = 6

退出：l = 5, r = 6

如果直接返回 l = 5：
  sum(5) = 10, diff = |10 - 10| = 0  ✅ 正确！
```

**例子2：** arr = [2, 3, 5], target = 9.5

```
二分过程：
l = 0, r = 6
val = 3: sum = 8 ≤ 9.5 → l = 3
val = 4: sum = 9 ≤ 9.5 → l = 4
val = 5: sum = 10 > 9.5 → r = 5

退出：l = 4, r = 5

分析：
calSum(4) = 9,  diff = |9 - 9.5| = 0.5
calSum(5) = 10, diff = |10 - 9.5| = 0.5

如果直接返回 l = 4：
  diff = 0.5，正确 ✅（因为差距相同，返回较小的）
```

**例子3：** arr = [2, 3, 5], target = 9.8

```
二分过程：
l = 0, r = 6
val = 3: sum = 8 ≤ 9.8 → l = 3
val = 4: sum = 9 ≤ 9.8 → l = 4
val = 5: sum = 10 > 9.8 → r = 5

退出：l = 4, r = 5

分析：
calSum(4) = 9,  diff = |9 - 9.8| = 0.8
calSum(5) = 10, diff = |10 - 9.8| = 0.2

如果直接返回 l = 4：
  diff = 0.8 ❌ 错误！
应该返回 r = 5，diff = 0.2 ✅
```

### 完整示例分析

**例子：** arr = [4, 9, 3], target = 10

```
二分过程：
l = 0, r = 10
val = 5: sum = 12 > 10 → r = 5
val = 2: sum = 6 ≤ 10 → l = 2
val = 3: sum = 9 ≤ 10 → l = 3
val = 4: sum = 11 > 10 → r = 4

退出：l = 3, r = 4

分析：
calSum(3) = 9,  diff = |9 - 10| = 1
calSum(4) = 11, diff = |11 - 10| = 1

如果直接返回 l = 3：
  diff = 1，正确 ✅（因为差距相同，返回较小的）
  
但如果 target = 9.5：
  calSum(3) = 9,  diff = |9 - 9.5| = 0.5
  calSum(4) = 11, diff = |11 - 9.5| = 1.5
  
  如果直接返回 l = 3：
    diff = 0.5，正确 ✅
    
但如果 target = 10.5：
  calSum(3) = 9,  diff = |9 - 10.5| = 1.5
  calSum(4) = 11, diff = |11 - 10.5| = 0.5
  
  如果直接返回 l = 3：
    diff = 1.5 ❌ 错误！
  应该返回 r = 4，diff = 0.5 ✅
```

### 为什么必须比较？

**核心原因：最优解可能在 l，也可能在 r！**

```
二分查找找到的是：
- l: sum(l) <= target 的最大值（在 target 左边或等于）
- r: sum(r) > target 的最小值（在 target 右边）

最优解是 |sum - target| 最小的：
- 如果 sum(l) 更接近 → 返回 l
- 如果 sum(r) 更接近 → 返回 r
- 如果一样接近 → 返回较小的（l）
```

### 可视化理解

```
target = 10

sum(value) 的变化：
value:  0   1   2   3   4   5
sum:    0   3   6   9  11  12
                ↑   ↑   ↑
              l=3  r=4
              
target = 10 ────┘   │   │
                    │   │
            sum(l)  │   sum(r)
            = 9     │   = 11
            diff=1  │   diff=1
            
两个候选值都需要考虑！
```

### 数学证明

**设：**
- `sum(l) = s1 ≤ target`
- `sum(r) = s2 > target`
- `target = t`

**需要比较：**
- `diff1 = |s1 - t| = t - s1`（因为 s1 ≤ t）
- `diff2 = |s2 - t| = s2 - t`（因为 s2 > t）

**最优解：**
- 如果 `diff1 < diff2` → 返回 `l`
- 如果 `diff1 > diff2` → 返回 `r`
- 如果 `diff1 = diff2` → 返回较小的（`l`）

**不能直接返回 `l`，因为 `diff2` 可能更小！**

---

## 总结

### 问题1：为什么 l = val，而不是 val + 1？

**答案：**
- `l` 表示"满足条件的最大值"，可以等于 `val`
- 如果 `l = val + 1`，会跳过 `val`，可能漏掉答案
- 双开区间的精髓：`l` 和 `r` 可以等于 `val`，不会跳过任何值

**记忆技巧：**
- `l` 和 `r` 表示"已经确认的边界"
- 边界可以等于当前值，不需要 +1 或 -1

### 问题2：为什么需要比较 diff1 和 diff2？

**答案：**
- 二分查找找到的是 `sum <= target` 的最大值，不是最接近的值
- 最优解可能在 `l`（target 左边），也可能在 `r`（target 右边）
- 必须比较两个候选值，选择更接近 target 的
- 如果差距相同，返回较小的（题目要求）

**记忆技巧：**
- 二分找的是"边界"，不是"最优解"
- 最优解在边界附近，需要比较两个边界值

### 双开区间模板（背下来）

```typescript
let l = 0, r = maxValue + 1  // 开区间

while (l + 1 < r) {
  const mid = (l + r) >> 1
  if (满足条件(mid)) {
    l = mid      // ✅ 不是 mid + 1
  } else {
    r = mid      // ✅ 不是 mid - 1
  }
}

// 退出时：l 是满足条件的最大值，r 是第一个不满足的
// 需要比较 l 和 r，选择更优的
const diff1 = Math.abs(target - calSum(l))
const diff2 = Math.abs(target - calSum(r))
return diff1 <= diff2 ? l : r
```

### 常见错误

**错误1：** `l = val + 1` 或 `r = val - 1`
- ❌ 会跳过正确答案
- ✅ 应该：`l = val` 或 `r = val`

**错误2：** 直接返回 `l`
- ❌ 可能不是最优解
- ✅ 应该：比较 `l` 和 `r`，选择更优的

**错误3：** 比较 `r` 和 `r + 1`
- ❌ `r + 1` 不在二分结果中
- ✅ 应该：比较 `l` 和 `r`

记住这两个关键点，双开区间二分就完全理解了！

