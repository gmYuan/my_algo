# 快排相关

## 理论前置

1 快排可以解决什么问题: 
  - 排序问题

2 快排的实现原理:
  - 分治思想
  - 先排序一个元素x，让其放到正确的位置==> 即 获取到一个索引idx，使得 左子数组满足[l, idx]<=x 和 右子数组满足 [idx+1, r]>=x
  - 再按照上述思想，递归 处理划分出的左右子数组，从而到最后会 正确排序数组里的每一个元素

3 快排的特点:
  - 快排 平均的时间复杂度是 O(nlogn)，如果划分的左右子数组成员数量不平衡，极端情况下会 退化到O(n^2)；
    如果使用三路快排，则可以避免退化到 O(n^2)
    
  - 快排 是不稳定的，即相同值的元素位置可能会发生变化



## 代码实现

方法1: 双指针实现-do...while 简洁版  数据复杂度: O(nlogn), 空间复杂度: O(1)

```ts
function quickSort(nums: number[]): number[] {
  innerSort(nums, 0, nums.length - 1);
  return nums
};

// 对[l, r]范围内的数组, 其中最左边的元素进行正确排序==> 使其放到正确位置
function innerSort(arr, l, r) {
  //S1 递归中止条件: 表示只有<=1个成员的数组，已经是有序的直接返回即可
  if (l >= r) return;

  //S2 随机选取元素 + 前后相碰指针==> [l, end]都<=x; [end+1,r]都>=x
  let rdx = Math.floor(Math.random() * (r - l + 1)) + l;
  [arr[l], arr[rdx]] = [arr[rdx], arr[l]];
  // 随机选取元素+交换过位置后，再从最左边元素开始partition流程
  let x = arr[l], start = l - 1, end = r + 1;

  //S3 进行partiton: 当指针没有相遇时进行分割定位，从而保证 [l, end]都<=x; [end+1,r]都>=x
  // 这里start <= end 也可以，但是没有必要，因为相等前的那一轮循环 其实已经必然 正确获取了分割点end
  while (start < end) {
    // 注意点1: 不会等于x, 保证了所有等于x的成员 都会被均分到了start/end的各自数组内
    do start++; while(arr[start] < x);
    do end--; while(arr[end] > x);
    // 注意点2: 如果没有start < end的限制, 就有可能错误把 >x的值换到了左子数组，把<x的换到右子数组里了
    // 比如考虑在置换过基准点后，还是 [1,2,3,4,5]的情况
    if (start < end) [arr[start], arr[end]] = [arr[end], arr[start]];
  }

  //S4 递归处理 正确位置分隔点2边的数组，最终实现递归对每个成员都进行正确排序
  // 取[l, end] 和 [end+1, r]的原因，是因为是使用了 do...while，导致了end本身的位置就是切割点位置
  innerSort(arr, l, end);
  innerSort(arr, end + 1, r);
}
```