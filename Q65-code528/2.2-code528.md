# code528- 按权重随机选择

## 实现思路

方法1： `数轴区间 二分查找法`

原idx：    0,   1,   2,    3
w/份额：    2,  3,   1,    2

前缀和idx： 0,   1,   2,   3,   4
前缀和：    0,   2,   5,   6,   8

区间：     [0, 2), 
               [2, 5), 
                    [5,  6), 
                         [6,   8)


S1 如何把圆盘 展开为 数轴

前缀和的最后一个值，就是概率圆盘的 总份额数(总分母),
把这个概率圆盘展开，就是一个 数轴,
数轴的右端点(截止点)，就是 总份额数，即 sums.at(-1);

对这个数轴按1个单位长度 进行标点，得到一系列 整数点,
那么 前缀和数组里的每个值，其实就是 按份额w 对这些整数点 进行分组;

如下图的 数轴：

0---  1---  2---3---4--- 5---6---7---8---9....--->
↓           ↓            ↓   ↓.      ↓
 g0 =  [0  2)
               
           g1 = [2      5)
          
                   g2 = [5   6)
                  
                       g3 =  [6     8)
                      
我们就创建了根据份额对应的 不同长度的分组：g0~g3;
注意，分组下标也是从0开始标记的,
这样 分组下标  就和  原数组的下标 一一对应了;

---------------------------------------------------
S2 如何确定按 概率返回 对应的数x 以及对应的idx

如果我们在 数轴范围内(数轴范围 由上可知是 sums.at(-1)) 随机取一整数点x,
那么这个x 必然属于 某个分组，
求出的 所属分组的idx，就是 原数组 的 下标idx;

而且由于 分组是按概率份额w 进行划分的,
所以 x也必然会遵循 分组的占比概率;


-------------------------------------------
S3 如何求出x 所属的 分组idx

由于分组 是根据前缀和的 每个成员 进行划分的，每个成员即是分组的右边界;
所以 根据 前缀和数组的 成员数量，就能知道 数轴被划分为多少个分组(len - 1);

我们在 这些分组断点中，我们按二分查找 mid端点,
再比较 x 和 sums[mid] 的大小，就能收敛确定 x 所属的 分组idx


关键点
  - 看到"概率"和"权重"，想到可以用"区间长度"来表示
  - 把"概率问题"转换成 "区间查找问题"


## 参考文档

[01- 方法1参考文档](https://leetcode.cn/problems/random-pick-with-weight/solutions/966335/cer-fen-xiang-jie-by-xiaohu9527-nsns/)


## 代码实现

1 方法1- 区间 二分查找
  - 时间复杂度：O(n * log(max-min))
  - 空间复杂度：O(n)

```ts
class Solution {
  sums: number[] = [0];

  constructor(w: number[]) {
    for (let i = 0; i < w.length; i++) {
      this.sums[i + 1] = this.sums[i] + w[i];
    }
  }

  pickIndex(): number {
    // 用区间代替 重复元素的概率分布
    // 以w = [1, 3]为例
    // 此时 前缀和数组是 [0, 1, 4]
    // x = [0, 1) 表示 下标0，weight = 1 的概率长度 区间
    // x = [1, 4) 表示 下标1，weight = 3 的概率长度 区间

    // 在[0, 总和)的 整数范围内，随机取一个数
    const x = ~~(Math.random() * this.sums.at(-1));

    // 使用二分查找，找到x 所属的区间

    // S1 x 和 前缀和数组的 关系是：
    //  sums[i]   表示第i个区间的 右边界
    //  sums[i-1] 表示第i个区间的 左边界

    // S2 具体区间划分：
    //    [0    1    4]  前缀和数组
    //     ↓    ↓    ↓
    //     0----1----4   数轴
    //     [0,1) [1,4)   实际区间
    //      idx0  idx1   对应原数组下标

    // S3 x落在区间的判断：
    //   如果 x < sums[mid]：
    //     - 说明 x在mid指向的数字左边
    //     - 所以 r = mid (继续在左半边找)
    //   否则：
    //     - 说明x在mid指向的 数字右边或等于
    //     - 所以 l = mid + 1 (继续在右半边找)

    // 一句话总结：在这个总长度区间里，找到x 所属的区间

    let l = -1, r = this.sums.length;
    while (l + 1 < r) {
      const mid = l + ((r - l) >> 1);
      if (this.sums[mid] > x) r = mid;
      else l = mid;
    }
    return l;
  }
}
```


方法2：伪造随机解法，了解即可

```ts
class Solution {
  // 使用元组类型定义桶结构
  private buckets: Array<[index: number, count: number]>;
  private cursor = { bucket: 0, count: 0 };

  constructor(w: number[]) {
    // 计算权重总和
    const sum = w.reduce((acc, cur) => acc + cur, 0);

    // 把权重数组转换成桶数组：
    //   - 把每个权重转换成 [索引,出现次数]
    //   - 滤掉出现次数为0的桶
    this.buckets = w
      .map((weight, index): [number, number] => [
        index,
        // 乘以10: 把小数转成整数, 避免小数被 Math.floor 完全抹掉
        Math.floor((weight / sum) * 10),
      ])
      .filter(([_, count]) => count > 0); // 移除计数为0的桶
  }

  pickIndex(): number {
    // 获取当前位置信息
    const { bucket, count } = this.cursor;

   // 检查当前桶是否用完, 如果用完了，移到下一个桶
    if (count >= this.buckets[bucket][1]) {
      this.cursor = {
        // 取余的目的是：让桶的访问形成一个循环
        // 当到达最后一个桶时，自动回到第一个桶
        // 从而保证多次调用时，从头开始不会越界
        bucket: (bucket + 1) % this.buckets.length,
        count: 0,
      };
      return this.pickIndex();
    }

    // 增加使用次数 并返回 当前桶的索引
    this.cursor.count++;
    return this.buckets[bucket][0];
  }
}
```