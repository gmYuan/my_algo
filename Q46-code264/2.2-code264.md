# code264- 丑数 II

## 实现思路

1 方法1：暴力解法：知道暴力解法，才能有更好的优化解法
  - 暴力解法：从1开始，不断判断一个数是否是丑数，直到找到第n个丑数
  - 判断一个数是否是丑数：
    - 不断除以2直到不能整除，相当于 “不断剥离2”
    - 不断除以3直到不能整除，相当于 “不断剥离3”
    - 不断除以5直到不能整除，相当于 “不断剥离5”
    - 如果最后剩下1，说明这个数只包含2,3,5这些质因子
  - 时间复杂度：O(n * log(m))，其中m是第n个丑数
  - 空间复杂度：O(1)

  - 暴力解法的缺点：
    - 需要遍历处理 很多非丑数
    - 对于每个数字都要进行多次除法运算 来判断是否为丑数


2 方法2：最小堆
  - 从最小丑数1开始，每次生成新的丑数时，将当前丑数分别乘以2、3、5，把得到的新丑数加入最小堆
  - 每次从堆顶取出最小的丑数，这就保证了我们按照顺序生成丑数
  - 使用一个集合去重，避免重复的丑数进入堆
  - 时间复杂度：O(n * log(n))，其中n是第n个丑数
  - 空间复杂度：O(n)

  - 最小堆的优点：
    - 直接生成丑数：不会额外处理很多非丑数
    - 避免重复计算：不需要 对每个数都进行多次除法运算，来判断是否为丑数


3 方法3：三指针
  - 用uglys有序数组来存储丑数，初始只有1
  - 在2、3、5 票价窗口分别设置指针，其指针指向的是之前的最小丑数
  - 每轮根据 更新窗口的最小值 和 非更新窗口的最小值，来入队本轮的最小丑数
  
  - 由于依次入队的都是 每轮的最小丑数
    - 所以 各个窗口在更新指针后，指向的必然是之前入队的所有丑数，不会有遗漏
    - 即 可以理解为 是一种 ”渐进式的 穷举遍历“，而不是和堆一样一次性入队
    - 以上即 保证了 ”有序性“ + ”无遗漏“
  
  - 为了防止有重复丑数，可以使用一个 集合/同时更新窗口指针 来去重 2种方法实现
  
  - 时间复杂度：O(n)
  - 空间复杂度：O(n)



## 参考文档

[01- 暴力 + 最小堆 参考文档](https://leetcode.cn/problems/ugly-number-ii/solutions/80955/bao-li-you-xian-dui-lie-xiao-ding-dui-dong-tai-gui/)

[02.1- 三指针的图示](https://leetcode.cn/problems/ugly-number-ii/solutions/2361819/264-chou-shu-iidong-tai-gui-hua-qing-xi-5e3up/)

[02.2- 三指针解法答疑](https://leetcode.cn/problems/ugly-number-ii/solutions/110653/san-zhi-zhen-fang-fa-de-li-jie-fang-shi-by-zzxn/)




## 代码实现

1 方法1: 最小堆/优先队列
  - 时间复杂度：O(n * log(n))，其中n是第n个丑数
  - 空间复杂度：O(n)

```ts
function nthUglyNumber(n: number): number {
  if (n <= 0) return 0;
  if (n === 1) return 1;
  const saved = new Set<number>();
  const heap = minHeap<number>((a, b) => a < b);
  heap.add(1);
  while (heap.size() && n > 0) {
    const cur = heap.removeTop();
    if (--n === 0) return cur;
    const nums = [cur * 2, cur * 3, cur * 5].filter((num) => !saved.has(num));
    nums.forEach((num) => {
      heap.add(num);
      saved.add(num);
    });
  }
}

function minHeap<T>(compare: (a: T, b: T) => boolean) {
  const heap: T[] = [];

  return {
    size: () => heap.length,
    peek: () => heap[0],
    add: (item: T) => {
      heap.push(item);
      siftUp(heap.length - 1);
    },
    removeTop: (): T => {
      const ret = heap[0];
      swap(0, heap.length - 1);
      heap.pop();
      siftDown(0);
      return ret;
    },
  };

  function swap(i: number, j: number) {
    [heap[i], heap[j]] = [heap[j], heap[i]];
  }

  function siftUp(idx: number) {
    while (idx > 0) {
      const parentIdx = ~~((idx - 1) / 2);
      // compare返回true: 说明需要上浮，即 当前子值 < 父值
      const willUp = compare(heap[idx], heap[parentIdx]);
      if (!willUp) break;
      swap(idx, parentIdx);
      idx = parentIdx;
    }
  }

  function siftDown(idx: number) {
    while (1) {
      const ldx = 2 * idx + 1, rdx = 2 * idx + 2;
      let smller = idx;
      // ldx < idx
      if (ldx < heap.length && compare(heap[ldx], heap[smller])) {
        smller = ldx;
      }
      // rdx < idx
      if (rdx < heap.length && compare(heap[rdx], heap[smller])) {
        smller = rdx;
      }
      if (smller === idx) break;
      swap(smller, idx);
      idx = smller;
    }
  }
}
```


2 方法2: 三指针/DP法
  - 时间复杂度：O(n)，其中n是传入的值
  - 空间复杂度：O(n)

```ts
function nthUglyNumber(n: number): number {
  if (n === 1) return 1;
  const uglys = [1];
  let i2 = 0, i3 = 0, i5 = 0;
  for (let i = 1; i < n; i++) {
    const next2 = uglys[i2] * 2;
    const next3 = uglys[i3] * 3;
    const next5 = uglys[i5] * 5;
    const min = Math.min(next2, next3, next5);
    uglys.push(min);
    if (min === next2) i2++;
    if (min === next3) i3++;
    if (min === next5) i5++;
  }
  return uglys[n - 1];
}

```