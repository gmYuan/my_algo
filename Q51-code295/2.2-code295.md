# code295- 数据流的中位数

## 实现思路

1 本题特点：
  - 是 动态地 添加数字
  - 需要随时能够获取中位数
  - 数据是持续流入的

2 暴力/直观 解法
  - 维护一个有序数组，每次插入时保持数组有序
  - 获取中位数时，直接访问中间位置
  - 但这样插入操作的时间复杂度是 O(n)，因为插入时 要移动元素
  - 为什么要移动元素：因为我们要保持整个数组都有序
  - 关键问题：我们真的需要整个数组都有序吗？


3.1 思考中位数的 定义/本质：
  - 中位数的定义是什么？是把数据分成相等两部分的 那个数
  - 对于有序数组 [1, 2, 3, 4, 5]，中位数是 3
  - 重要观察：3 左边的数都比 3 小，右边的数都比 3 大， 3 是中位数
  - 更重要的观察：左边具体是 1, 2 还是 2, 1 的顺序并不重要，右边是 4, 5 还是 5, 4 的顺序也不重要
  - 所以，我们只需要 “找到中位数” 即可，不需要整个数组都有序

3.2 也就是说，我们只需要知道
  - 左半部分的最大值（因为这可能是中位数）
  - 右半部分的最小值（因为这也可能是中位数）
  - 其他数字的具体顺序都不重要

3.3 引入堆的契机：
  - 需求1：快速获取一组数中的 最大值/最小值
  - 需求2：快速增删元素
  - 这正是堆数据结构的特长！
  - 大顶堆可以快速获取最大值，小顶堆可以快速获取最小值


4 总结以上 思维方式：
  - 当发现一个直观解法效率不够时
  - 回到问题本质，看看是否 真的需要所有的操作
  - 找到关键信息，用更高效的数据结构来维护


```text
直观解法：[1, 2, 3, 4, 5] 完全有序数组
                ↓
优化思路：只需要知道 [1, 2] 中的最大值和 [4, 5] 中的最小值
                ↓
最终方案：大顶堆 [1, 2] 和小顶堆 [3, 4, 5]
```


## 参考文档

[01- 方法1参考文档](https://leetcode.cn/problems/find-median-from-data-stream/solutions/3015873/ru-he-zi-ran-yin-ru-da-xiao-dui-jian-ji-4v22k/)



## 代码实现

1 方法1: 最大堆 && 最小堆
  - 时间复杂度： addNum O(logq)
    - q 是 addNum 的调用次数
  - 空间复杂度： O(q)

```ts
class minHeap<T> {
  private data: T[];
  private compare: (a: T, b: T) => boolean;

  constructor(compare: typeof this.compare) {
    this.compare = compare;
    this.data = [];
  }

  // 使用 getter 替代方法
  get size() {
    return this.data.length;
  }

  get peek() {
    return this.data[0];
  }

  enque(item: T) {
    this.data.push(item);
    this.siftUp(this.size - 1);
  }

  deque() {
    // 易错点1：如果堆为空，直接返回，防止堆中误进入'undefined'
    if (this.size === 0) return;
    // 易错点2：只有一个的时候直接出队，防止后续操作数组长度不会减少
    if (this.size === 1) return this.data.pop();
    const ret = this.data[0];
    this.data[0] = this.data.pop();
    this.siftDown(0);
    return ret;
  }

  private siftUp(idx: number) {
    while (idx > 0) {
      const pdx = (idx - 1) >> 1;
      // compre为true: a < b; 即 cur < parent
      const willUp = pdx >= 0 && this.compare(this.data[idx], this.data[pdx]);
      if (!willUp) break;
      this.swap(idx, pdx);
      idx = pdx;
    }
  }

  private siftDown(idx: number) {
    while (1) {
      let ldx = idx * 2 + 1, rdx = ldx + 1;
      let ndx = idx;
      if (ldx < this.size && this.compare(this.data[ldx], this.data[ndx]))
        ndx = ldx;
      if (rdx < this.size && this.compare(this.data[rdx], this.data[ndx]))
        ndx = rdx;
      if (ndx === idx) break;
      this.swap(idx, ndx);
      idx = ndx;
    }
  }

  private swap(i: number, j: number) {
    [this.data[i], this.data[j]] = [this.data[j], this.data[i]];
  }
}

class MedianFinder {
  // 较小部分的 最大堆: 通过compare来控制反转为 最大堆
  private left: minHeap<number>;
  // 较大部分的 最小堆
  private right: minHeap<number>;

  constructor() {
    // 保证 left.size === right.size 或者 left.size === right.size + 1
    this.left = new minHeap((a, b) => a > b);
    this.right = new minHeap((a, b) => a < b);
  }

  addNum(num: number): void {
    // 成员个数相等，统一逻辑以简化代码：进右出最小的，进左
    if (this.left.size === this.right.size) {
      this.right.enque(num);
      this.left.enque(this.right.deque());
    } else {
      // left.size === right.size + 1，统一逻辑以简化代码：进左出最大的，进右
      this.left.enque(num);
      this.right.enque(this.left.deque());
    }
  }

  findMedian(): number {
    return this.left.size > this.right.size
      ? this.left.peek
      : (this.right.peek + this.left.peek) / 2;
  }
}
```