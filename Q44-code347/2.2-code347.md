# code347- 前 K 个高频元素

## 实现思路

1 方法1：快排实现

基本同 code973

------------------------
2 方法2: 最大堆实现

基本同 code973

---------------------------
3 方法3 桶排序

1 统计每个元素出现的次数: Map
2 创建频率桶:
  - 索引为频率，值是该频率的 元素数组
  - 长度为 n + 1, 因为频率最大为 n && idx 从 0 开始

3 从后向前遍历频率桶，直到收集到 前k个高频元素时，返回结果数组
  - 使用 res.length < k 作为条件，确保只收集前k个高频元素



## 参考文档

[01- 方法1和方法2参考实现](https://leetcode.cn/problems/top-k-frequent-elements/solutions/404339/4-chong-fang-fa-miao-sha-topkji-shu-pai-xu-kuai-pa/)

[02- 方法3桶排序实现](https://leetcode.cn/problems/top-k-frequent-elements/solutions/3655287/tong-pai-xu-on-xian-xing-zuo-fa-pythonja-oqq2/)



## 代码实现

1 方法1: 快排实现  时间复杂度: O(n);  空间复杂度 O(logn)

```ts
function topKFrequent(nums: number[], k: number): number[] {
  const record = new Map();
  for (const num of nums) {
    record.set(num, (record.get(num) || 0) + 1);
  }
  const arr: [number, number][] = Array.from(record);
  quickSel(arr, 0, arr.length - 1, k - 1);
  // 易错点1： 要直接返回前k个元素
  return arr.slice(0, k).map((item) => item[0]);
}

function quickSel( arr: Array<[number, number]>, l: number, r: number, k: number): void {
  if (l >= r) return;
  const p = partition(arr, l, r);
  if (p === k) return;
  if (p < k) quickSel(arr, p + 1, r, k);
  if (p > k) quickSel(arr, l, p - 1, k);
}

function partition(arr: Array<[number, number]>, l: number, r: number): number {
  const rdx = ~~(Math.random() * (r - l + 1)) + l;
  swap(arr, l, rdx);
  // 易错点2：所有左边界都是l，而不是0
  // [l, i）>= x;  (j, r] <= x
  let x = arr[l][1], i = l + 1, j = r;
  while (1) {
    while (i <= j && arr[i][1] > x) i++;
    while (i <= j && arr[j][1] < x) j--;
    if (i > j) break;
    swap(arr, i++, j--);
  }
  swap(arr, l, --i);
  return i;
}

function swap(arr: Array<[number, number]>, l: number, r: number): void {
  [arr[l], arr[r]] = [arr[r], arr[l]];
}
```

------------------------
2 方法2 最大堆  时间复杂度: O(nlogk); 空间复杂度: O(n)

```ts
type TArrWithFre = ReturnType<typeof createArrWithFre>[number];
type THeap = ReturnType<typeof createMaxHeap>;

function topKFrequent(nums: number[], k: number): number[] {
  const arrWithFre = createArrWithFre(nums);
  const heap = createMaxHeap<TArrWithFre>((a, b) => b.fre - a.fre);
  return arrWithFre.reduce(processArr(k), heap).getNums();
}

function createArrWithFre(arr: number[]) {
  const record = new Map<number, { num: number; fre: number }>();
  arr.map((val) => {
    record.set(val, {
      num: val,
      fre: (record.get(val)?.fre || 0) + 1,
    });
  });
  return [...record.values()];
}

function createMaxHeap<T extends TArrWithFre>(compare: (a: T, b: T) => number) {
  let heap: T[] = [];
  return {
    getSize,
    peek() {
      return heap[0];
    },
    add(item: T) {
      heap.push(item);
      siftUp(heap.length - 1);
    },
    replace(item: T) {
      const max = heap[0];
      heap[0] = item;
      siftDown(0);
      return max;
    },
    getNums() {
      return heap.map((item) => item.num);
    },
  };

  function getSize() {
    return heap.length;
  }

  function siftUp(idx: number) {
    //S1 循环更新：比较父节点与当前节点大小
    //S2 当 当前节点值 > 父节点值 时，则交换位置 + 更新当前index
    while (idx > 0) {
      const parentIdx = (idx - 1) >> 1;
      const curIsLarger = compare(heap[idx], heap[parentIdx]) > 0;
      if (!curIsLarger) break;
      swap(heap, idx, parentIdx);
      idx = parentIdx;
    }
  }

  function siftDown(idx: number) {
    while (1) {
      // 取左右子节点中最大的
      let maxIdx = idx;
      const leftIdx = idx * 2 + 1;
      const rightIdx = idx * 2 + 2;
      if (leftIdx < getSize() && compare(heap[leftIdx], heap[maxIdx]) > 0) {
        maxIdx = leftIdx;
      }
      if (rightIdx < getSize() && compare(heap[rightIdx], heap[maxIdx]) > 0) {
        maxIdx = rightIdx;
      }
      if (maxIdx === idx) break;
      swap(heap, idx, maxIdx);
      idx = maxIdx;
    }
  }

  function swap(arr: T[], l: number, r: number) {
    [arr[l], arr[r]] = [arr[r], arr[l]];
  }
}

function processArr(k: number) {
  return (heap: THeap, cur: TArrWithFre) => {
    if (heap.getSize() < k) {
      heap.add(cur);
    } else if (cur.fre > heap.peek().fre) {
      heap.replace(cur);
    }
    return heap;
  };
}
```

----------------------------------
3 方法3 桶排序  时间复杂度: O(n); 空间复杂度: O(n)

```ts
function topKFrequent(nums: number[], k: number): number[] {
  // S1 统计每个元素出现的次数
  const record = new Map<number, number>();
  for (const num of nums) {
    record.set(num, (record.get(num) || 0) + 1);
  }
  // S2 创建频率桶，其中最大频率可以节省空间，它可能小于 nums.length
  const maxFreq = Math.max(...record.values());
  const bucket = Array.from({ length: maxFreq + 1 }, () => []);

  // S3 将元素添加到频率桶中
  for (const [num, freq] of record.entries()) {
    bucket[freq].push(num);
  }

  // S4 从后向前遍历频率桶，收集前k个高频元素
  // 易错点：是前k个高频元素，而不是 频率是排名前k的 所有元素
  const res = [];
  for (let i = maxFreq; i >= 0 && res.length < k; i--) {
    res.push(...bucket[i]);
  }
  return res;
}
```
