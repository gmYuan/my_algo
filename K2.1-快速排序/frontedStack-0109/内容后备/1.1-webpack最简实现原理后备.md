

------------------------------------------------------------------
Q5.1 最基础的bundle.js是如何实现的/ webpack最基础版本的 打包流程是什么

A: <br/>

1. 整个文件是 一个立即执行函数(IIFE)，这是 Webpack打包后的 典型结构

2.1 定义 `__webpack_modules__` 对象， 它包含了所有模块的代码
  - key: 模块的相对路径
  - value: 模块内部代码，被封装成一个函数

2.2 定义 `__webpack_module_cache__` 对象，用于缓存 已加载的模块

2.3 定义 `__webpack_require__` 函数，这是 Webpack 的模块加载器

2.4 调用 `__webpack_require__("./src/index.js")` ==> 这是整个应用的入口点==>

3 开始加载 "./src/index.js" 模块==>
  - 3.1 检查模块是否已缓存，这里是首次加载，所以未缓存
  - 3.2 创建一个新的 module 对象并存入缓存
  - 3.3 执行 "./src/index.js" 对应的 value函数==>


4.1 "./src/index.js" 模块对应 value函数被执行==> 
  - 输出 "Hello Webpack" 到控制台
  - 调用 `__webpack_require__("./src/a.js")` 加载 a.js 模块。

5 `__webpack_require__` 再次被调用，这次是加载 "./src/a.js" 模块：
  - 5.1 检查缓存，未找到
  - 5.2 创建新的 module 对象并缓存
  - 5.3 执行 "./src/a.js" 对应的函数

6  "./src/a.js" 模块被执行：
  - 6.1 设置 `module.exports` 为 '我是a.js导出内容'

4.2 控制权返回到 "./src/index.js"：
  - 将 a.js 的导出内容赋值给 `str` 变量
  - 输出 "str是----" 和 `str` 的值到控制台


总结关键流程为:

> 1. 使用IIFE创建模块作用域
> 2. webpack_modules_存储所有模块
> 3. webpack_require_实现模块加载
> 4. 从入口模块开始，递归加载所有依赖

> 入口文件 -> 依赖解析 -> 模块转换 -> 模块合并 -> 输出bundle
------------------------------------------------------------------
Q5.2 最基础的bundle.js的实现方式，有什么作用/实现技巧

A: <br/>

1. 模块化封装
  - 把所有模块，都封装在一个 IIFE里 来创建一个私有作用域==> 避免全局变量污染，保证模块间的隔离

2. 依赖解析 + 模块内容 封装为函数
  - `__webpack_modules__` 对象 包含了入口模块 & 依赖模块的 {模块路径: 模块内部代码} 
  - 每个模块内部代码 都被转换为一个函数，这使得模块可以延迟执行，只在被require时 才真正运行==> 按需加载

3. 模块缓存
  - `__webpack_module_cache__` 对象用于缓存已加载的模块
  - 这种设计可以避免重复加载同一模块，提高性能 + 确保模块单例性==> 避免重复加载 + 优化性能

4. 模块加载器：模块系统的核心
  - `__webpack_require__` 函数模拟了 CommonJS 的 require 功能==> 实现了浏览器端的模块化
  - 它负责 加载模块 + 缓存模块 + 执行模块代码，并返回模块的 exports对象
  - 有一个明确的执行入口：`__webpack_require__("./src/index.js")`






