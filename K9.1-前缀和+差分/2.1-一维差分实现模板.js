/** 

差分：

1.1 差分可以看作是前缀和的逆运算:
  - 如果把数组a 的前缀和数组记为s，那么 a 就是 s 的差分数组

即 对于一个数组 a[1...n]，其差分数组 d[1...n] 定义为：
  d[1] = a[1]
  d[i] = a[i] - a[i-1] (i > 1)

所以 差分数组d 记录的是a内 相邻元素之间的差值


1.2 差分的作用: 用于 快速对数组进行 区间修改
  
即 如果要对原数组 a 的区间 [l,r] 进行整体加上某个值 v
在差分数组上只需要：d[l] += v, d[r+1] -= v
时间复杂度从 O(n) 优化到 O(1)

1.3 实现原理：
  - 通过原始数组a 初始化a的 差分数组d
  - 通过差分数组d 实现区间修改==> 利用的是前缀和的定义
  - 通过差分数组d 恢复出修改后的数组a

*/

// 根据数组a, 初始化a的 差分数组d
function initDiff(a) {
  const d = [];
  d[0] = a[0];
  for (let i = 1; i < a.length; i++) {
    d[i] = a[i] - a[i - 1];
  }
  return d;
}

// 对数组a的区间[l,r] 整体加上v
// 宏观角度：
// 因为 d[l] 是 a[l] 的差分数组/ a[l] 是 d[l] 的前缀和
// 所以 d[l] 加上v 就等价于 a[l] && 之后的每一项都 加上v
// 而 d[r+1] 减去v 就等价于 a[r+1] && 之后的每一项都 减去v
// 也就是 a[l]...a[r]直接都被 加上v

function addV(a, l, r, v) {
  let d = initDiff(a);
  // 微观角度：
  // 因为 d[l] = a[l] - a[l-1]
  // 所以 d[l] 加上v 等价于 a[l] 加上v
  // 而 d[l + 1] = a[l + 1] - a[l] 值不变
  // 就意味着 a[l] + v后, a[l+1] 也被间接加上v了
  d[l] += v;
  // 关键修改：需要判断 r+1 是否超出数组范围
  if (r + 1 < a.length) {
    // 添加边界检查
    d[r + 1] -= v;
  }
  return recover(d);
}

// 通过差分数组d 恢复出修改后的数组a
function recover(d) {
  const a = [];
  a[0] = d[0];
  for (let i = 1; i < d.length; i++) {
    // a[i] = a里面前一个位置的值 + 当前位置和a[i-1]的差值
    a[i] = a[i - 1] + d[i];
  }
  return a;
}
