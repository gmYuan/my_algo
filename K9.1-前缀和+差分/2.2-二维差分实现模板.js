/** 
二维差分：

题目：
输入一个n行m列的整数矩阵;
再输入q个操作，每个操作包含五个整数x1,y1,x2,y2,c，
其中(x1,y1)和(x2,y2)表示一个子短阵的左上角坐标和右下角坐标。
每个操作都要将选中的子短阵中的每个元系的值加上c。
请你将进行完所有操作后的 矩阵输出。

输入格式：
第一行包含整数n, m, q
接下来n行，每行包含m个整数，表示整数矩阵
接下来q行，每行包含5个整数x1,y1,x2,y2,c，表示一个操作。
输出格式
共n行，每行m个整数，表示所有操作进行完毕后的最终短阵。

数据范围
1 ≤ n, m ≤ 1000
1 < q < 100000
1 ≤ x1 ≤ x2 ≤ n
1 ≤ y1 ≤ y2 ≤ m

*/


/***
二维差分前置知识点:

1.1 假设一个数组是a， 其差分数组是b，其前缀和数组是c
则有：
  - 原数组a 是 差分数组b 的前缀和数组

1.2 在对 差分数组b 的 某个区间[x1,x2] 加上某个值val时，
则有：
  - 原数组a 的 对应区间[x1,x2] 也会加上val，因为a是b的前缀和数组

即: 差分是在记录"变化量"; 前缀和是在 累加这些"变化量"


2.1 二维差分的实现过程理解:

b[x1][y1] += val 会影响到：
  - 这个点右边的所有点（因为前缀和会用到左边的值）
  - 这个点下边的所有点（因为前缀和会用到上边的值）


b[x2+1][y1] -= val   // 下边界
b[x1][y2+1] -= val   // 右边界

因为前缀和计算时：  
  - 下边界的-val会抵消从上面传播下来的val
  - 右边界的-val会抵消从左边传播过来的val


b[x2+1][y2+1] += val
因为边界的两个-val会在右下角重复减：
- 从下边界传播过来一个-val
- 从右边界传播过来一个-val
所以需要+val来修正重复减去的部分

 */

// 处理二维矩阵-差分操作
function process2DMatrixOperations(arr, n, m, actions) {
  // 初始化差分矩阵
  let diff = Array(n + 1).fill().map(() => Array(m + 1).fill(0));

  // 构建差分矩阵
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      insert(diff, i, j, i, j, arr[i - 1][j - 1]);
    }
  }

  // 处理操作
  for (let [x1, y1, x2, y2, val] of actions) {
    insert(diff, x1, y1, x2, y2, val);
  }

  // 计算结果（前缀和）
  let res = [];
  for (let i = 1; i <= n; i++) {
    res[i - 1] = [];
    for (let j = 1; j <= m; j++) {
      // 注意这里需要累加
      diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
      res[i - 1][j - 1] = diff[i][j];
    }
  }

  return res;
}

// 子矩阵区域的批量修改 操作实现
function insert(b, x1, y1, x2, y2, val) {
  // 起点标记 +val
  b[x1][y1] += val;
 // 阻止 加值继续 向一下传播
  b[x2 + 1][y1] -= val;
  // 阻止 加值继续 向右一列传播
  b[x1][y2 + 1] -= val;
  // 角落修正 +val
  b[x2 + 1][y2 + 1] += val;
}


// process2DMatrix(
//   [
//     [1, 2, 2, 1],
//     [3, 2, 2, 1],
//     [1, 1, 1, 1],
//   ],
//   3,
//   4,
//   [
//     [1, 1, 2, 2, 1],
//     [1, 3, 2, 3, 2],
//   ]
// );
