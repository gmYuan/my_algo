// 二维 前缀和

/** 
1.1 二维前缀和的核心目的是：快速求出任意矩形区域的和。

1.2 每个位置s[i][j] 存储的是从 (0,0) 到 (i,j)的 矩形和,
  即 每一行/每一列 形成的矩形，而非跨行的非矩形和  
  这样设计可以让我们用简单的减法求出 任意矩形区域的和

  即:
  (1,1) = 2 表示从(1,1)到(1,1)的矩形和
  (1,2) = 5 表示从(1,1)到(1,2)的矩形和
  (2,1) = 6 表示从(1,1)到(2,1)的矩形和
  (2,2) = 10 表示从(1,1)到(2,2)的矩形和


1.3 为什么是矩形：
  - 因为大多数实际问题中，我们需要计算的都是矩形区域
  - 矩形有规则的形状，便于用坐标表示（只需要两个点就能确定一个矩形）
  - 矩形可以用简单的减法运算 得到任意子矩形的和
  - 而 非矩形的形状难以用简单的坐标表示 + 计算会变得很复杂


2.1 二维前缀和的计算实现（i是行; j是列）：
  s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]

2.2 如何理解:
  - s[i][j] 表示的是一个矩形块的和（一块空间的和），而不是一个点
  - 画一个矩形图 + 容斥原理


3.1 查询任意 子矩形区域和：
  s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1]

*/

// 构建 二维前缀和数组, 注意 m>=1, n>=1, a 的行列下标都是从1开始的
function initPrefixSum(m, n, a) {
  // S1 创建前缀和数组s，大小为(m+1)*(n+1)，初始化为0
  const s = Array(m + 1)
    .fill(0)
    .map(() => Array(n + 1).fill(0));

  // S2 构建前缀和，注意i和j都是从1开始 (i表示行，j表示列)
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
    }
  }

  return s;
}

// 3. 查询(x1,y1)到(x2,y2)矩形区域和
function querySum(s, { x1, y1 }, { x2, y2 }) {
  // x1/x2 表示行，也就是矩形的高度
  // y1/y2 表示列，也就是矩形的宽度

  // s[x2][y1-1]表示 左侧矩形
  // s[x1-1][y2]表示 上方矩形
  // s[x1-1][y1-1]表示 左上角矩形(长是x1-1, 宽是y1-1)
  return s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1];
}