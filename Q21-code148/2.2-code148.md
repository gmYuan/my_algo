# LeetCode148- 排序链表

## 实现思路

### 1- 自底向上排序

1 自底向上sort = step * (cut + merge):
  - 分别以 1/2/4/8/k个节点为 1组车组 + 对车组(a, b)两两配对 排序合并

2.1 获取 第1组车厢 头节点a1

2.2 通过cut: 斩断a1所有尾结点 + 返回第2组车厢 头节点b1

2.3 通过cut: 斩断b1所有尾结点 + 返回下一队车厢(a2, b2)中 a2

2.4 更新cur, 让它指向 下一队待处理车厢的头节点a2
  - 由于 后续merge 需要斩断尾结点才能正确处理节点，后续还要能 处理下一队车厢
  - 所以只能在这里 更新cur的指向

2.5 merge: 合并+排序(a1 + b1) 这一队车厢，返回排好序的 这对车厢的头节点x

2.6 更新pre，以保证pre指向为 下一队车厢(a2, b2)中 a2的前一个节点




## 参考文档

[01 方法1图示参考](https://leetcode.cn/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/)


## 代码实现

1 方法1: 自底向上归并排序，时间复杂度 O(n * logn)  空间复杂度O(1)

```ts
function sortList(head: ListNode | null): ListNode | null {
  // 处理特殊情况
  if (!head || !head.next) return head

  //S1 设置虚拟头节点
  let dummy = new ListNode(-1, head)

  //S2 获取链表长度，用于明确 归并的截止长度
  let len = 0;
  let cur = head;
  while (cur) {
    len++;
    cur = cur.next;
  }

  //S3 分别以 1/2/4/8/k个节点为 1节车厢 + 对车厢(a, b)两两配对，进行排序
  for (let step = 1; step < len; step *= 2) {
    let pre = dummy; // pre固定指向 每轮循环中的 每对配对车厢(a,b)中的 a1的前一个节点
    // 易错点1: cur不能指向head 
    let cur = dummy.next; // cur固定指向每轮循环中的 每对配对车厢(a,b)中的 a头节点
    // 易错点2: 每节车厢需要保证cur有值
    while (cur) {       
      let a1 = cur;           // 获取a车厢的 头节点a1
      let b1 = cut(a1, step); // 根据a1 + step, 得到b车厢的 头节点b1
      cur = cut(b1, step);   // 更新cur为下一对车厢的头结点a2, 同时隐式切断了b1的尾节点
      // 更新pre, 以保证pre指向为 下一对车厢(a2, b2)中 a2的前一个节点
      pre.next = merge(a1, b1);
      while (pre.next) {
        pre = pre.next;
      }
    }
  }
  return dummy.next;
};


// 对以head为头结点的链表，截断前n个节点，返回截断后的新头节点
function cut(head: ListNode, n: number) {
  while (head && --n > 0) head = head.next;
  const bHead = head ? head.next : null;
  if (head) head.next = null;
  return bHead;
}
    
// 合并 l1和l2 2个有序链表
function merge(l1: ListNode, l2: ListNode) {
  let dummy = new ListNode(-1)
  // 易错点: 为了返回头节点，需要要有新对象pre，用于后移指针
  let pre = dummy
  while (l1 && l2) {
    if (l1.val < l2.val) {
      pre.next = l1
      l1 = l1.next
    } else {
      pre.next = l2
      l2 = l2.next
    }
    pre = pre.next
  }
  pre.next = l1 ? l1 : l2
  return dummy.next
}
```
