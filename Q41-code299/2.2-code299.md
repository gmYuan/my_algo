# code299- 猜数字游戏

## 实现思路

1 数字次数统计法

1.1 错误思路
  - S1 创建secret的 (idx: val) 记录对
  - S2 遍历guess
    如果(idx, val) 都对，则作为 A长度+1 + 删除该记录
    如果val对, idx不对，则作为 B长度+1 + 删除该记录
    如果val不对, idx不对，直接略过

错误点: 以上实现会出现  误删除 后一个位置是正确公牛的情况
如 secret = "011"
   guess =  "110"

1.2 正确思路是，
  - 创建 0~9数字的出现次数 统计
  - 先处理完所有的公牛情况，再单独处理奶牛
  - 奶牛的个数，应该是secret 和 guess 对应0~9数字 的出现的最小次数



## 参考文档

[01- 方法1参考实现](https://leetcode.cn/problems/bulls-and-cows/solutions/2677744/yue-du-li-jie-pythonjavacgojsrust-by-end-84f0/)


## 代码实现

1 方法1: 数字次数统计法  时间复杂度: O(n);  空间复杂度 O(1)

```ts
function getHint(secret: string, guess: string): string {
  let bulls = 0;
  // 长度为10的数组，记录secret中每个数字（0-9）的出现次数（排除公牛后）
  const secretCount = new Array(10).fill(0);
  // 长度为10的数组，记录guess中每个数字（0-9）的出现次数（排除公牛后）
  const guessCount = new Array(10).fill(0);

  // 题目保证了secret.length == guess.length
  for (let i = 0; i < secret.length; i++) {
    if (secret[i] === guess[i]) {
      // 如果 位置和值 都相等：说明是公牛，bulls++
      bulls++;
    } else {
      // 将这两个数字分别计入统计数组（排除公牛后的统计）
      // 等价于 secretCount[+secret[i]] = secretCount[+secret[i]] + 1
      secretCount[+secret[i]]++;
      guessCount[+guess[i]]++;
    }
  }

  // 计算奶牛数量：遍历secretCount，
  // count：当前数字在secret中的出现次数
  // i：当前数字（0-9）
  // guessCount[i]：当前数字在guess中的出现次数

  // 对于每个数字，取该数字在secret和guess中的出现次数的最小值
  // 累加得到奶牛数量
  const cows = secretCount.reduce(
    (sum, count, i) => sum + Math.min(count, guessCount[i]),
    0
  );
  // 返回结果格式：公牛数量 + "A" + 奶牛数量 + "B"
  return `${bulls}A${cows}B`;
}

```


