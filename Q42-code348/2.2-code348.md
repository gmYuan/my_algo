# code348- 设计井字棋

## 实现思路

1 方法1：增量更新 + 计数追踪
  - 我们只关心：每行/列/对角线被同一玩家占据了多少个位置
  - 只存储"获胜条件"的状态，而不是整个棋盘状态
  - 这种"增量更新"的思想 在很多算法题中都很常见，比如滑动窗口、前缀和等，都是避免重复计算，利用已知信息快速得到新结果


1.2 具体分析过程

S1 理解题目核心
  - 首先明确题目要求：每次落子后，判断是否有玩家获胜。
  - 获胜条件是：同一行、同一列 或 同一对角线 都被 同一玩家占据

S2 从简单情况开始思考：暴力解法
  - 每次落子后，检查所有行、列、对角线
  - 时间复杂度：O(n²)，因为要遍历整个棋盘

S3.1 寻找优化思路：观察获胜模式
  - 获胜需要：某一行全部相同，或某一列全部相同，或某条对角线全部相同
  - 关键点：不需要检查整个棋盘，只需要检查当前落子影响的行、列、对角线

S3.2 计数思维
  - 对于每一行：记录每个玩家在该行的棋子数量
  - 对于每一列：记录每个玩家在该列的棋子数量
  - 对于对角线：记录每个玩家在对角线的棋子数量
  - 当某个玩家的计数达到n时，就获胜了

S4 边界情况考虑
  - 对角线：只有落子在主对角线或副对角线时才需要更新
  - 玩家标识：可以用1和2，或者1和-1来区分
  - 平局情况：当棋盘满了但没有获胜者


## 参考文档

[01- 方法1参考实现](https://leetcode.jp/leetcode-348-design-tic-tac-toe-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/)



## 代码实现

1 方法1: 增量更新 + 计数追踪  时间复杂度: O(1);  空间复杂度 O(n)

```ts
class TicTacToe {
  private n: number;
  private rows: number[];
  private cols: number[];
  private diagonals: number[];
  constructor(n: number) {
    // 创建 n行 * n列 + 2条对角线的 记录
    this.n = n;
    this.rows = new Array(n).fill(0);
    this.cols = new Array(n).fill(0);
    // diagonals[0]主对角线，diagonals[1]副对角线
    this.diagonals = [0, 0];
  }

  move(row: number, col: number, player: number): number {
    // 使用 1 和 -1 来区分玩家，简化计算
    const val = player === 1 ? 1 : -1;
    const n = this.n;
    // 更新行计数 和 列计数
    this.rows[row] += val;
    this.cols[col] += val;
    // 更新主对角线：其特点是 row === col
    // 如：(0,0) (1,1) (2,2)...
    if (row === col) this.diagonals[0] += val;
    // 更新副对角线：其特点是 row + col === n - 1
    // 如：(0,2) (1,1) (2,0)...
    if (row + col === n - 1) this.diagonals[1] += val;
    // 判断落下了 该行/该列/该对角线后，此时是否有绝对值 达到了n
    if (
      Math.abs(this.rows[row]) === n ||
      Math.abs(this.cols[col]) === n ||
      Math.abs(this.diagonals[0]) === n ||
      Math.abs(this.diagonals[1]) === n
    ) {
      return player;
    }
    // 否则说明落完这一子后，当前还没有获胜者
    return 0;
  }
}
```