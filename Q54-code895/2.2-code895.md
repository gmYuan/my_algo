# code895- 最大频率栈

## 实现思路

1 方法1：buckets + Map

1.1 分析题目要求
  - 需要记录频率
  - 频率相同时要取最近的
  - 最难的是 "频率相同时取最近的" 这个要求
  - 这暗示了我们需要某种方式保存元素的 "时序信息"

1.2 常见数据结构分析
  - 堆？可以，但处理相同频率时需要额外信息
  - 栈？天然保持时序，但不好处理频率
  - Map？可以记录频率，但不保持时序


1.3 关键突破点
  - 如果能把 "相同频率" 的元素放在一起
  - 又能保持它们的入栈顺序
  - 那不就自然解决了问题吗？

1.4 灵感来源
  - 这类题目的一个常见技巧是 "分组"
  - 比如桶排序就是按数值分组
  - 这里我们可以按频率分组！

这种解法的巧妙之处在于：
  - 把频率作为分组依据，自然解决了"找最高频率"的问题
  - 每个频率组用数组存储，自然保持了入栈顺序
  

## 参考文档

[01- 方法1参考文档](https://leetcode.cn/problems/maximum-frequency-stack/solutions/1998430/mei-xiang-ming-bai-yi-ge-dong-hua-miao-d-oich/)


## 代码实现

1 方法1: buckets + Map
  - 时间复杂度：O(1)
  - 空间复杂度：O(n)

```ts
class FreqStack {
  // idx是 频率freq，val是 出现的元素栈
  private buckets: number[][] = [];
  // key是num, val是freq
  private freqs = new Map<number, number>();

  push(val: number): void {
    const freq = (this.freqs.get(val) ?? 0) + 1;
    this.freqs.set(val, freq);
    // 如果当前频率超过现有栈数，创建新栈
    (this.buckets[freq] ??= []).push(val);
  }

  pop(): number {
    const val = this.buckets.at(-1).pop();
    // 如果最高频率栈为空，移除该栈
    if (!this.buckets.at(-1).length) this.buckets.pop();
    // 更新频率
    const freq = this.freqs.get(val) - 1;
    freq ? this.freqs.set(val, freq) : this.freqs.delete(val);
    return val;
  }
}
```