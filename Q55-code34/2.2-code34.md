# code34- 在排序数组中查找元素的第一个和最后一个位置

## 实现思路

1 方法1：二分查找

1 实现思路

1.1 第1个位置：>=t的最小值 (minGt); 最后1个位置: <=t的最大值 (maxLt)


1.2 所有大小关系的整数查找，都可以转化为 minGt
  - maxLt，可以转化为 >= (t + 1)的最小值 - 1，即 minGt(t + 1) - 1
  - > t的 最小值，可以转化为 >= (t + 1)的最小值，即 minGt(t + 1)
  - < t的 最大值，可以转化为 >= t的最小值 - 1，即 minGt(t) - 1


2.1  二分法里的区间，其含义是
  - 区间内的，表示的是 还未处理的的元素
  - 区间外的，表示的是 已经确定处理过的元素
  - 所以开闭区间，表示的就是【当前还未处理的元素】，是否 不包括/包括 这个idx的值


2.2 区间维护的本质
  - 二分查找的核心就是不断缩小"待查找区间"
  - [left, right] 区间内的元素代表"还需要继续判断的范围"
  - 区间外的元素要么已确定不是答案，要么已确定是答案

  

## 参考文档

[01- 方法1参考文档](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/1980196/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9/)


## 代码实现

1.1 方法1.1- 双开区间
  - 时间复杂度：O(logn)
  - 空间复杂度：O(1)

```ts
function searchRange(nums: number[], target: number): number[] {
  const lt = minGt(nums, target);
  // 易错点1: 如果lt 超出范围，或者lt 不等于target，说明不存在
  if (lt === nums.length || nums[lt] !== target) return [-1, -1];
  // <=t的最大值 (maxLt)相当于 minGt(t+1) - 1
  const gt = minGt(nums, target + 1) - 1;
  return [lt, gt];
}

// 获取 >=t的 最小值
function minGt(nums: number[], target: number): number {
  // 左右都是开区间，从而保证整个内部区间都是未处理过的
  // 开区间说明了未处理的元素，不包括-1 和 len
  // 即 [-Infinity, -1]都 < t, [len, Infinity]都 >= t
  let l = -1, r = nums.length;
  // 如果l + 1 === r，说明此时l和r都被处理过了，此时区间内没有待处理元素
  while (l + 1 < r) {
    const mid = l + ((r - l) >> 1);
    if (nums[mid] < target) {
      l = mid;
    } else {
      r = mid;
    }
  }
  // 到此时，l必然是 < t的最后一个元素，r必然是 >= t的第1个元素
  return r;
}
```


1.2 方法1.2- 左闭右开区间
  - 时间复杂度：O(logn)
  - 空间复杂度：O(1)

```ts
function searchRange(nums: number[], target: number): number[] {
  const lt = minGt(nums, target);
  // 易错点1: 如果lt 超出范围，或者lt 不等于target，说明不存在
  if (lt === nums.length || nums[lt] !== target) return [-1, -1];
  // <=t的最大值 (maxLt)相当于 minGt(t+1) - 1
  const gt = minGt(nums, target + 1) - 1;
  return [lt, gt];
}

// minGt： >=t的最小值- 左闭右开区间实现
function minGt(nums: number[], target: number): number {
  // 表示 未处理的元素- 包括l; 不包括r
  let l = 0, r = nums.length;
  // 包括l，不包括r, 所有l === r时(如 [4,4)时)，说明没有元素需要处理了
  // 所以循环条件是 l < r
  while (l < r) {
    const mid = (l + r) >> 1;
    if (nums[mid] < target) {
      l = mid + 1;
    } else {
      r = mid;
    }
  }
  // 任意返回l或者r都可，因为循环结束时 l === r
  return r;
}
```