# LeetCode144- 二叉树的前序遍历

## 实现思路

1 思维关键词: 
  - 方法1: 栈循环 + {command, node}节点法
  - 方法2: DFS==> 前序递归 + innerPre(root, res)


2 参考文档

[01 方法1参考](https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/)

[02 方法2参考](https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/cer-cha-shu-san-chong-bian-li-qian-zhong-erk2/)


## 代码实现

方法1: 迭代法  时间复杂度 O(n)  空间复杂度：O(n)

```ts
function preorderTraversal(root: TreeNode | null): number[] {
  if (!root) return []
  let stack = [{command: 'go', node: root}], res = []

  while (stack.length) {
    const {command, node} = stack.pop()
    if (command === 'print') {
      res.push(node.val)
      // 打印时就不需要 再重复添加节点到栈里了
      continue;
    }   
    if (node.right) {
      stack.push({ command: 'go', node: node.right })
    }
    if (node.left) {
      stack.push({ command: 'go', node: node.left })
    }
    stack.push({ command: 'print', node: node })
  }
  return res
};
```

方法2: 递归法  时间复杂度 O(n)  空间复杂度：O(n)

```ts
function preorderTraversal(root: TreeNode | null): number[] {
  if (!root) return []
  let res = []
  innerPre(root, res)
  return res
};

function innerPre(node: TreeNode | null, res: number[]) {
  res.push(node.val)
  if (node.left) {
    innerPre(node.left, res)
  }
  if (node.right) {
    innerPre(node.right, res)
  }
}
```