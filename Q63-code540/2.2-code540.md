# code540- 有序数组中的单一元素

## 实现思路

1 分组错位 二分查找

1.1 以m个元素为1组，对其进行分组，获取其分组的l 和 r 边界值

1.2 分组后的元素 具有以下可二分的性质：
  - 把 每分组的索引，记作 k
  - 每组的 开头元素，其对应的nums的索引为 m * k
  - 如果 nums[m * k] === nums[m * k + 1]，则说明该组未受到单一元素的影响，则单一元素在右半部分
  - 反之，则说明受到了单一元素的影响，则单一元素在 当前分组的左半部分

举例，以 m = 2为例
nums:      0, 0,    1, 1,     2,     3, 3
分组:      (0  1)    (2  3)   (4)   (5  6)
分组索引:     0         1       2       3

1.3 易错点：最后返回的值，应该是分组k 对应的i，即 nums[m * k]


## 参考文档

[01- 方法1参考文档](https://leetcode.cn/problems/single-element-in-a-sorted-array/solutions/2983333/er-fen-xing-zhi-fen-xi-jian-ji-xie-fa-py-0rng/)


## 代码实现

1 方法1- 分组错位 二分查找
  - 时间复杂度：O(logn/m)
  - 空间复杂度：O(1)

```ts
function singleNonDuplicate(nums: number[]): number {
  return findM(nums, 2)
}

// 在以m个元素进行重复的 有序数组nums里，找到唯一的 无重复的 元素
function findM(nums: number[], m: number): number {
  let l = -1, r = ~~((nums.length + 1) / m)
  while (l + 1 < r) {
    const mid = (l + r) >> 1
    if (nums[mid * m] !== nums[mid * m + 1]) {
      r = mid
    } else {
      l = mid
    }
  }
  return nums[r * m]
}
```