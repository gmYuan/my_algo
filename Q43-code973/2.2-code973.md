# code973- 最接近原点的 K 个点

## 实现思路

1 方法1：快排partition- 思考路径：

S1 问题转化：找最近的k个点 → 找距离第k小的点==> TopK问题

S2 快排/最大堆(优先队列) 都可以解决 TopK问题

S3.1 快排本质 && 优化点
  - 排序所有元素：对所有元素排序，但我们只需要前k个
  - 快速选择：只关心第k小的位置，其他元素不需要完全排序
  - 快排的本质：分治法，将问题分解为子问题，然后递归处理子问题
  - 每次partition 都能排除一半的元素


S3.2 快排实现步骤
  - 随机选择一个基准点p
  - 将小于基准点p 的放左边，大于基准点p的 放右边
  - 如果p的位置正好是k，就找到了
  - 如果p的位置小于k，就递归处理右边的点
  - 如果p的位置大于k，就递归处理左边的点


2 方法2: 最大堆实现 时间复杂度: O(nlogk); 空间复杂度: O(k)

S1 通过 最大堆/优先队列 存储K个元素

S2 维护 最大堆的性质，返回最后结果


## 参考文档

[01- 直接参考实现](https://leetcode.cn/problems/k-closest-points-to-origin/solutions/478516/kuai-lai-miao-dong-topkkuai-pai-bian-xing-da-gen-d/)



## 代码实现

1 方法1: 快排partition 时间复杂度: O(n);  空间复杂度 O(logn)

```ts
function kClosest(points: number[][], k: number): number[][] {
  let pointsWithDis = points.map(([x, y]) => ({
    point: [x, y],
    dis: x * x + y * y,
  }));
  // 第k小个数，对应的下标是 k-1
  quickSel(pointsWithDis, 0, points.length - 1, k - 1);
  return pointsWithDis.slice(0, k).map(({ point }) => point); 
};

function quickSel(arr, l, r, k) {
  if (l >= r) return;
  const p = partition(arr, l, r);
  if (p === k) return;
  if (p < k) quickSel(arr, p + 1, r, k);
  if (p > k) quickSel(arr, l, p - 1, k);
}

function partition(arr, l, r) {
  // [0,1) ==> [0, r+1) ==> [0, r]==> [l, r + l]
  // const rdx = l + Math.floor(Math.random() * (r + 1));
  // 所以正确的思考步骤应该是: [0, r-l+1) ==> [0, r-l]==>  [l, r]
  const rdx = l + ~~(Math.random() * (r - l + 1));
  swap(arr, l, rdx);
  const x = arr[l].dis;
  // 保证性质[l, i) <= x; (j, r] >= x
  let i = l + 1, j = r;
  while (1) {
    while (i <= j && arr[i].dis < x) i++;
    while (i <= j && arr[j].dis > x) j--;
    if (i > j) break;
    swap(arr, i++, j--);
  }
  // 运行到此，此时必然满足[l, i-1] <= x && [i, r] >= x
  // 所以把x放到 i-1位置 + 返回i-1 即可,即 --i
  swap(arr, l, --i);
  return i;
}

function swap(arr, l, r) {
  [arr[l], arr[r]] = [arr[r], arr[l]];
}
```


2 方法2: 最大堆实现 时间复杂度: O(nlogk); 空间复杂度: O(k)

```ts
type TPoint = ReturnType<typeof createPointsWithDis>[number];
type THeap<T> = ReturnType<typeof createMaxHeap<T>>;

function kClosest(points: number[][], k: number): number[][] {
  // S1 创建带有距离的Point
  const pointsWithDis = createPointsWithDis(points);
  // S2 创建最大堆
  const heap: THeap<TPoint> = createMaxHeap<TPoint>((a, b) => a.dis - b.dis);
  // S3 在堆中处理点，并返回处理后的堆
  const processedHeap = pointsWithDis.reduce(processPoint(k), heap);
  // S4 返回堆中的点
  return processedHeap.getArr().map(({ point }) => point);
}

function createPointsWithDis(points: number[][]) {
  return points.map(([x, y]) => ({
    point: [x, y],
    dis: x * x + y * y,
  }));
}

function createMaxHeap<T>(compare: (a: T, b: T) => number) {
  const heap: T[] = [];
  return {
    getSize,
    peek,
    add,
    replace,
    getArr: () => heap,
  };

  function getSize() {
    return heap.length;
  }

  function peek() {
    return heap[0];
  }

  function add(item: T) {
    heap.push(item);
    siftUp(getSize() - 1);
  }

  function replace(item: T) {
    const max = peek();
    heap[0] = item;
    siftDown(0);
    return max;
  }

  function siftUp(idx: number) {
    //S1 循环更新：比较父节点与当前节点大小
    //S2 当 当前节点值 > 父节点值 时，则交换位置 + 更新当前index
    while (idx > 0) {
      const parentIdx = ~~((idx - 1) / 2);
      const curIsLarger = compare(heap[idx], heap[parentIdx]) > 0;
      if (!curIsLarger) break;
      swap(heap, idx, parentIdx);
      idx = parentIdx;
    }
  }

  function siftDown(idx: number) {
    // 上浮/下沉是一个 深度比较操作，所以需要循环更新
    while (1) {
      // S1 获取左右子节点中较大索引值
      const left = 2 * idx + 1;
      const right = 2 * idx + 2;
      let largerIdx = idx;

      if (left < getSize() && compare(heap[left], heap[largerIdx]) > 0) {
        largerIdx = left;
      }
      if (right < getSize() && compare(heap[right], heap[largerIdx]) > 0) {
        largerIdx = right;
      }
      // S2 比较子节点和当前节点值，子节点较小时 则停止，否则交换位置
      if (largerIdx === idx) break;
      swap(heap, idx, largerIdx);
      idx = largerIdx;
    }
  }
}

function swap(arr: any[], l: number, r: number) {
  [arr[l], arr[r]] = [arr[r], arr[l]];
}

function processPoint(k: number) {
  return (heap: THeap<TPoint>, point: TPoint) => {
    if (heap.getSize() < k) {
      heap.add(point);
    } else if (point.dis < heap.peek().dis) {
      heap.replace(point);
    }
    return heap;
  };
}
```