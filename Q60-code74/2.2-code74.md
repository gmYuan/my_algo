# code74- 搜索二维矩阵

## 实现思路

1 一维映射 二分法

1.1 映射二维后纵坐标取模后不需要-1的原因，举例说明：
  -  m = 3, n = 4
  - 矩阵按行展开为一维数组：[1, 3, 5, 7,  10, 11, 16, 20,  23, 30, 34, 60]
  - 一维索引：             0  1  2  3   4   5   6   7    8   9  10  11

第一轮循环： mid = (-1 + 12) >> 1 = 5
mid = 5 对应一维数组中索引5的位置，值为11
转换为二维坐标：
  行坐标 = ~~(5 / 4) = 1
  列坐标 = 5 % 4 = 1

所以访问 matrix[1][1] = 11 ✓


2 行列收缩法
  - 从右上角开始搜索，先确定行，再收缩列



## 参考文档

[01- 方法1参考文档](https://leetcode.cn/problems/search-a-2d-matrix/solutions/2783931/liang-chong-fang-fa-er-fen-cha-zhao-pai-39d74/)


## 代码实现

1 方法1- 一维映射 二分法
  - 时间复杂度：O(logn)
  - 空间复杂度：O(1)

```ts
function searchMatrix(matrix: number[][], target: number): boolean {
  const m = matrix.length, n = matrix[0].length;
  let l = -1, r = m * n;
  while (l + 1 < r) {
    let mid = (l + r) >> 1;
    // 易错点1：由于二维数组也是从0开始索引的，所以列索引取模后不需要-1
    const x = matrix[~~(mid / n)][mid % n];
    if (x === target) return true;
    if (x > target) {
      r = mid;
    } else {
      l = mid;
    }
  }
  return false;
}
```


2 方法2- 行列收缩法
  - 时间复杂度：O(m + n)
  - 空间复杂度：O(1)

```ts
function searchMatrix(matrix: number[][], target: number): boolean {
  const m = matrix.length, n = matrix[0].length;
  // 从右上角开始搜索，先确定行，再收缩列
  let row = 0, col = n - 1;
  while (row < m && col >= 0) {
    const x = matrix[row][col];
    if (x === target)  return true;
    // 当前行的最大值 小于目标值，（排除此行）向下移动行
    if (x < target) {
      row++; 
    } else {
      // 当前行的最大值 大于目标值，（排除此列）向左移动列
      col--; 
    }
  }
  return false;
}
```