// 实现的关键是理解 乘法的数学性质
// 123 * 11 ==>
//  (1 * 10^2 + 2 * 10^1 + 3 * 10^0) * 11
//  (3 * 11 * 10^0) + (2 * 11 * 10^1) + (1 * 11 * 10^2)
//  33 * 1 + 22 * 10 + 11 * 100

// 计算方法1==> 先乘后加: 先分类，再求和
//  33 + 220 + 1100
//  (3×1 + 3×10 ) + (2×10 + 2×100 ) + (1×100 + 1×1000)

// 可以理解为 1个10元的硬币 + 3个1元的 + 5个1角的 + 3个1分的
//  3×1 + 5×10 + 3×100 + 1×1000

//  1353

// 计算方法2==> 边乘边加: 边数边进位/ 逢10进1
//  33 + 220 + 1100

// 数到33个1分硬币时：把30个1分转化为 3个1分的 + 3个1角的
// 33 = 3×10 + 3 

// 继续数，现在是22 + 3 = 25个1角的，把它换成: 5个1角的 + 2个1元的 
// 22 + 3 = 25 = 2×10 + 5

// 继续数，现在是 11 + 2 = 13个1元的，把它换成: 3个1元的 + 1个10元的
// 11 + 2 = 13 = 1×10 + 3

// 最后结果就是
// 1 * 1000(1个10元的) + 3 * 100(3个1元的) + 5 * 10 (5个1角的) + 3 * 1 (3个1分的) = 1353 (单位: 分)


// 实现一个大整数 和 一个小整数 相乘功能
function bigNumberMul(num1, num2) {
  // S1 按低位-->高位 顺序生成每位的 数组，从而把大整数num1 转换为 数组
  const arr1 = String(num1).split("").reverse();
  // S2 具体大数相乘实现
  let res = mulImp(arr1, num2);
  // S3 由于数组结果是按低位-->高位顺序生成，所以需要反转成 高位-->低位来显示
  return res.reverse().join("");
}

// 具体大数相乘实现
function mulImp(arr1, num2) {
  if (num2 === 0) return [0];
  let res = [];
  let carry = 0;
  for (let i = 0; i < arr1.length || carry > 0; i++) {
    const curVal = Number(arr1[i] || 0) * num2 + carry;
    // 保存当前位的 个位数值
    res.push(curVal % 10);
    // 保存当前位计算结果的 进位
    carry = Math.floor(curVal / 10);
  }
  return res;
}

console.log(bigNumberMul(1234, 11));
